<?php

namespace App\Traits;
use DB;
use Auth;
use SturdflexProductMasters;
use SturdflexPriceRequestMasters;
use SturdflexPriceRequestVariantMasters;
use SturdflexPricingRequestLogs;
use Log;
/*
|------------------------------------------------
| Trait to get reuseable systemwide
| RFQ Datapoints
|------------------------------------------------
 */

trait RfqTrait {

    /**
     * return meta for sturdflex pricing request (rfq)
     * @param array
     * @return string
     */
    public function getSturdflexRfqDependencies() {

        $paymentTerms    = config('sturdflex.PAYMENT_TERMS_STATUS');
        $supplyMethods   = config('sturdflex.SUPPLY_METHOD_STATUS');
        $dealer          = $this->getDealerData();
        $competitors     = config('sturdflex.COMPETITORS');
        $productType     = config('sturdflex.PRODUCT_TYPE');
        $rfqStatusMaster = config('status.STURDFLEX_APPROVAL_STATUS');
        $columns         = ['id', 'product_name', 'description', 'sap_code', 'price', 'uom', 'image', 'status', 'created_by'];
        $masters         = SturdflexProductMasters::with('variants')->select($columns)->where('status', 1)->get();
        $products        = [];
        foreach ($masters as $master) {
            $products[] = [
                'id'               => $master->id,
                'product_name'     => $master->product_name,
                'hex_code'         => $master->hex_code,
                'description'      => $master->description,
                'sap_code'         => $master->sap_code,
                'price'            => $master->price,
                'uom'              => $master->uom,
                'image'            => $master->image,
                'product_category' => $master->product_category,
                'variants'         => $master->variants->toArray()
            ];

        }

        $data = [
            'products'       => $products,
            'rfq_status'     => $rfqStatusMaster,
            'supply_methods' => $supplyMethods,
            'payment_terms'  => $paymentTerms,
            'competitors'    => $competitors,
            'dealer'         => $dealer,
            'product_type'   => $productType
        ];

        return $data;
    }

    /**
     * returns request code (rfq)
     * @param none
     * @return string
     */
    public function generateRequestCode() {

        $lastCode = SturdflexPriceRequestMasters::select('id', 'request_code', 'project_id')->with(['project' => function ($Q) {
            $Q->select('account_id', 'account_type', 'state_id');
            $Q->with('state:state_id,short_name');
        }])->latest()->first();

        if (!$lastCode) {
            $code = 'SFPR-WB-000001';
        } else {
            $stateShortName = isset($lastCode->project) && isset($lastCode->project->state) ? $lastCode->project->state->short_name : '';
            $code           = (int) $lastCode->id + 1;
            $code           = 'SFPR-' . $stateShortName . '-' . str_pad($code, 6, '0', STR_PAD_LEFT);
        }

        return $code;
    }

    /**
     * returns boolean and logs && updates request (rfq)
     * @param none
     * @return boolean
     */
    public function createLogAndUpdateModel($params) {
        try {
            $transaction = DB::transaction(function () use ($params) {

                $type           = $params['type'] ?? 0;
                $fieldKeyValues = $params['fieldKeyValues'] ?? [];
                $modelName      = $this->getModelName($params['type']);
                $sourceType     = $params['sourceType'] ?? 2;
                $createdBy      = Auth::user()->id ?? 1;
                $createdAt      = date('Y-m-d H:i:s');
                $keyName        = $params['keyName'] ?? 'id';
                $keyValue       = $params['keyValue'] ?? null;
                $requestId      = $params['request_id'] ?? $keyValue;
                $doUpdate       = $params['doUpdate'] ?? false;
                $actionType     = $params['action_type'] ?? 'EDIT';
                if ($keyName == null || $keyValue == null || count($fieldKeyValues) === 0) {
                    return false;
                }
                $logArray              = [];
                $fields                = implode(',', array_keys($fieldKeyValues));
                $whereCondition        = $params['additionalWhereCondition'] ?? null;
                $whereConditionPayload = [$keyName => $keyValue];
                if ($whereCondition !== null) {
                    $whereConditionPayload = array_merge($whereConditionPayload, $whereCondition);
                }

                if (in_array($actionType, ['EDIT', 'TRASH'])) {

                    $modelData = collect($modelName::where($whereConditionPayload)->first())->toArray();

                    foreach ($fieldKeyValues as $eachFieldName => $eachFieldValue) {
                        $previousValue = $modelData[$eachFieldName] ?? null;
                        if ($previousValue !== null) {
                            if ($previousValue != $eachFieldValue) {
                                if ($eachFieldName === 'status') {
                                    $statusCollection = collect(config('status.STURDFLEX_APPROVAL_STATUS'));
                                    $previousValue    = $statusCollection->where('id', $previousValue)?->first()['status'];
                                }
                                $logArray[] = [
                                    'model_id'     => $keyValue,
                                    'request_id'   => $requestId,
                                    'field'        => $eachFieldName,
                                    'request_type' => $type,
                                    'source_type'  => $sourceType,
                                    'from_value'   => $previousValue,
                                    'to_value'     => $eachFieldValue,
                                    'action_type'  => $actionType,
                                    'created_at'   => $createdAt,
                                    'created_by'   => $createdBy
                                ];
                            }
                        }
                    }
                } else {
                    foreach ($fieldKeyValues as $eachFieldName => $eachFieldValue) {
                        $logArray[] = [
                            'model_id'     => $keyValue,
                            'request_id'   => $requestId,
                            'field'        => $eachFieldName,
                            'request_type' => $type,
                            'source_type'  => $sourceType,
                            'from_value'   => 'NEW ITEM',
                            'to_value'     => $eachFieldValue,
                            'action_type'  => $actionType,
                            'created_at'   => $createdAt,
                            'created_by'   => $createdBy
                        ];
                    }
                }

                if (count($logArray) > 0) {

                    SturdflexPricingRequestLogs::insert($logArray);
                    if ($doUpdate) {
                        $modelName::where($whereConditionPayload)->update($fieldKeyValues);
                    }
                    return true;
                }

                return false;
            }, 2);

            return true;
        } catch (\Exception $error) {
            Log::info('LOG ERROR::::');
            Log::info($error->getMessage());
            return false;
        }

    }

    /**
     * global date format (rfq)
     * @param date
     * @return string
     */
    public function formatDate($date) {
        return !empty($date) && !is_null($date) ? date('l, jS F Y', strtotime($date)) : NULL;
    }

    /**
     * returns model class (rfq)
     * @param none
     * @return string
     */
    public function getModelName($type) {
        $modelName = '';
        switch ($type) {
            case 0:
                $modelName = SturdflexPriceRequestMasters::class;
                break;
            case 1:
                $modelName = SturdflexPriceRequestVariantMasters::class;
                break;
        }

        return $modelName;
    }

    /**
     * returns status id (rfq)
     * @param params.request_id
     * @return int
     */
    public function getStatus($params) {
        try {
            $requestId                 = $params['request_id'] ?? 0;
            $typeOfUser                = strtoupper($params['type_of_user'] ?? 'asm');
            $status                    = NULL;
            $rfqStatusMasterCollection = collect(config('status.STURDFLEX_APPROVAL_STATUS'));

            if ($requestId > 0) {
                $statusName                      = $typeOfUser . ' approved';
                $statusNamePartial               = $typeOfUser . ' partially approved';
                $statusValue                     = $rfqStatusMasterCollection->where('status', $statusName)->pluck('id')->first();
                $itemsTotalQuantity              = collect(SturdflexPriceRequestVariantMasters::where('request_id', $requestId)->select('id', 'request_id', 'quantity', 'status')->get());
                $variantsApprovedModelCollection = collect(SturdflexPriceRequestVariantMasters::where('request_id', $requestId)->where('status', $statusValue)->select('id', 'request_id', 'quantity', 'status')->get());
                $variantsApprovedTotalQuantity   = $variantsApprovedModelCollection->sum('quantity');
                $variantRequestedTotalQuantity   = $itemsTotalQuantity->sum('quantity');

                if ($variantsApprovedTotalQuantity < $variantRequestedTotalQuantity) {
                    $status = $rfqStatusMasterCollection->where('status', $statusNamePartial)->pluck('id')->first();
                } else if ($variantsApprovedTotalQuantity === $variantRequestedTotalQuantity) {
                    $status = $rfqStatusMasterCollection->where('status', $statusName)->pluck('id')->first();
                }
            }

            return $status;
        } catch (\Exception $error) {
            return $error->getMessage();
        }
    }

    /**
     * returns status id by approval type(approve/reject) and user type(so/asm/ho/hod/director) (rfq)
     * @param params.request_id
     * @return int
     */
    public function getStatusByType($type, $userType = 'ho') {

        $statusId         = 0;
        $statusCollection = collect(config('status.STURDFLEX_APPROVAL_STATUS'));

        switch ($type) {
            case 'approve':
                $status = strtoupper($userType) . ' approved';
                //echo $status;
                $statusId = $statusCollection->where('status', $status)->pluck('id')->first();
                break;

            case 'reject':
                $status   = strtoupper($userType) . ' rejected';
                $statusId = $statusCollection->where('status', $status)->pluck('id')->first();
                break;

            default:
        }

        return $statusId;

    }

    /**
     * get dealer data from dealer master and sturdflex retail master;
     */
    public function getDealerData() {
        $dealers = DB::select('
            SELECT dealer_id,name,sap_code,account_type FROM tbl_dealer_masters WHERE account_type =39
            UNION
            SELECT account_id AS dealer_id,account_name AS name, account_code AS sap_code,account_type FROM tbl_sturdflex_retailer_masters WHERE account_type =79');
        foreach ($dealers as $dealer) {
            $dealerId          = $dealer->dealer_id;
            $dealerName        = $dealer->name;
            $dealerAccountType = $dealer->account_type;
            $dealerSapCode     = $dealer->sap_code;
            $dealerData        = [
                'dealer_id'    => $dealerId . '_' . $dealerAccountType,
                'name'         => $dealerName,
                'account_type' => $dealerAccountType,
                'sap_code'     => $dealerSapCode
            ];
            $dealerDataArray[] = $dealerData;
        }
        return $dealerDataArray;
    }

}
